<!DOCTYPE html>
<html>
  <head>
    <title>great</title>
    <link rel="icon"href="icon.png.png">
  </head>
  <body>
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>迷跡旅館 — 完整版</title>
<style>
html,body{height:100%;margin:0;background:#000;font-family:Arial,sans-serif}
canvas{display:block;width:100vw;height:100vh}
.overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:20;color:#fff}
.menu{background:rgba(24,24,24,0.98);padding:18px;border-radius:10px;text-align:center}
.btn{padding:8px 14px;margin:6px;border-radius:6px;border:none;cursor:pointer;font-weight:700}
.btn-easy{background:#2ecc71;color:#012}.btn-normal{background:#f1c40f}.btn-hard{background:#e67e22}.btn-hell{background:#e74c3c}
#hud{position:fixed;left:12px;top:12px;z-index:15;color:#fff;font-weight:700;text-shadow:0 0 6px #000}
#hud div{margin-bottom:6px}
#infoSmall{font-size:13px;opacity:.9;margin-top:8px}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="menuOverlay" class="overlay">
  <div class="menu">
    <h2>迷跡旅館 — 選擇難度</h2>
    <div id="controls" style="margin-bottom:8px">控制：方向鍵/WASD移動，空白鍵射擊（嚇退鬼），F 切換手電筒</div>
    <div>
      <button class="btn btn-easy" onclick="startGame('EASY')">EASY</button>
      <button class="btn btn-normal" onclick="startGame('NORMAL')">NORMAL</button>
      <button class="btn btn-hard" onclick="startGame('HARD')">HARD</button>
      <button class="btn btn-hell" onclick="startGame('HELL')">HELL</button>
    </div>
    <div id="infoSmall">EASY 3 發 / NORMAL 4 發 / HARD 6 發 / HELL 8 發。射完後每 30 秒補一發，最多為該難度上限。</div>
  </div>
</div>

<div id="hud" style="display:none">
  <div id="levelText">Level: 1</div>
  <div id="diffText">Difficulty: NORMAL</div>
  <div id="ammoText">Ammo: 0 / 0</div>
  <div id="ghostText">Ghosts: 0</div>
  <div id="tipText">F: 手電筒 切換</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize); resize();

const TILE = 28;
const MAP_COLS = 40;
const MAP_ROWS = 40;

const DIFF = {
  'EASY':   { maxAmmo: 3,  ghostCount:3, ghostSpeed:2500 },
  'NORMAL': { maxAmmo: 4,  ghostCount:4, ghostSpeed:1800 },
  'HARD':   { maxAmmo: 6,  ghostCount:6, ghostSpeed:1200 },
  'HELL':   { maxAmmo: 8,  ghostCount:8, ghostSpeed:1000 }
};

let maze=[], player={x:1,y:1}, ghosts=[], bullets=[];
let level=1, difficulty='NORMAL', started=false, flashlightOn=true, gameOver=false;
let ammo=0, lastAmmoRegen=0;

const menuOverlay = document.getElementById('menuOverlay');
const hud = document.getElementById('hud');
const levelText = document.getElementById('levelText');
const diffText = document.getElementById('diffText');
const ammoText = document.getElementById('ammoText');
const ghostText = document.getElementById('ghostText');

const keys={};
addEventListener('keydown', e=>{
  keys[e.key]=true;
  if(e.key==='f'||e.key==='F') flashlightOn=!flashlightOn;
  if(e.key===' ') tryShoot();
});
addEventListener('keyup', e=>{ keys[e.key]=false; });

function generateMaze(cols,rows){
  const grid = Array.from({length:rows},()=>Array(cols).fill('W'));
  function carve(x,y){
    grid[y][x]='.';
    const dirs=[{x:2,y:0},{x:-2,y:0},{x:0,y:2},{x:0,y:-2}].sort(()=>Math.random()-0.5);
    for(const d of dirs){
      const nx=x+d.x, ny=y+d.y;
      if(nx>0 && ny>0 && nx<cols-1 && ny<rows-1 && grid[ny][nx]==='W'){
        grid[y+d.y/2][x+d.x/2]='.';
        carve(nx,ny);
      }
    }
  }
  carve(1,1); grid[1][1]='.'; grid[rows-2][cols-2]='.';
  return grid;
}

function isWalkable(x,y){ return y>=0 && y<MAP_ROWS && x>=0 && x<MAP_COLS && maze[y][x]==='.'; }
function clamp(n,a,b){ return Math.max(a,Math.min(b,n)); }

function spawnGhosts(){
  ghosts=[];
  let placed=0;
  while(placed<DIFF[difficulty].ghostCount){
    let gx=2+Math.floor(Math.random()*(MAP_COLS-4));
    let gy=2+Math.floor(Math.random()*(MAP_ROWS-4));
    if(isWalkable(gx,gy) && (Math.abs(gx-1)+Math.abs(gy-1)>6) && (Math.abs(gx-(MAP_COLS-2))+Math.abs(gy-(MAP_ROWS-2))>6)){
      const type = placed%2===0?'skull':'wave';
      ghosts.push({x:gx,y:gy,type,stunUntil:0,lastMove:0});
      placed++;
    }
  }
}

function startLevel(){
  maze=generateMaze(MAP_COLS,MAP_ROWS);
  player.x=1; player.y=1;
  spawnGhosts();
  ammo=DIFF[difficulty].maxAmmo;
  lastAmmoRegen=performance.now();
  updateHUD();
}

function startGame(diff){
  difficulty=diff||'NORMAL'; level=1;
  menuOverlay.style.display='none'; hud.style.display='block';
  started=true; gameOver=false;
  startLevel();
}

function showMenu(){ started=false; menuOverlay.style.display='flex'; hud.style.display='none'; gameOver=true; }

function updateHUD(){
  ammoText.textContent=`Ammo: ${ammo} / ${DIFF[difficulty].maxAmmo}`;
  ghostText.textContent=`Ghosts: ${ghosts.length}`;
  levelText.textContent=`Level: ${level}`;
  diffText.textContent=`Difficulty: ${difficulty}`;
}

let lastMoveTick=0;
function tryMove(dx,dy){
  const now=performance.now();
  if(now-lastMoveTick<120) return;
  lastMoveTick=now;
  const nx=player.x+dx, ny=player.y+dy;
  if(isWalkable(nx,ny)) player.x=nx, player.y=ny;
}

function stepTowards(x,y,tx,ty){ //簡單貪婪
  const dx=tx-x, dy=ty-y;
  if(Math.abs(dx)>Math.abs(dy)){
    if(isWalkable(x+Math.sign(dx),y)) return {x:x+Math.sign(dx),y};
    if(isWalkable(x,y+Math.sign(dy))) return {x,y:y+Math.sign(dy)};
  } else {
    if(isWalkable(x,y+Math.sign(dy))) return {x,y:y+Math.sign(dy)};
    if(isWalkable(x+Math.sign(dx),y)) return {x:x+Math.sign(dx),y};
  }
  return {x,y};
}

// ----------- 子彈系統 ----------
const bulletSpeed=8;
function tryShoot(){
  if(ammo<=0) return;
  ammo--; updateHUD();
  bullets.push({x:player.x+0.5,y:player.y+0.5,dx:0,dy:0});
}

// ----------- 繪圖 ----------
let frame=0;
function drawGhost(g,camX,camY){
  const sx=g.x*TILE-camX+TILE/2;
  const sy=g.y*TILE-camY+TILE/2;
  ctx.save(); ctx.translate(sx,sy);
  if(g.type==='skull'){
    ctx.fillStyle='#e22';
    ctx.beginPath(); ctx.arc(0,-6,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#b10'; ctx.beginPath(); ctx.ellipse(0,6,14,16,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-5,-8,3,0,Math.PI*2); ctx.arc(5,-8,3,0,Math.PI*2); ctx.fill();
  } else {
    ctx.fillStyle='#e33';
    ctx.beginPath(); ctx.arc(0,-6,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#b11'; ctx.beginPath();
    ctx.moveTo(-14,8);
    for(let i=-14;i<=14;i+=7) ctx.quadraticCurveTo(i,18+Math.sin((i+frame)/6)*4,i+7,8);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-5,-8,2.5,0,Math.PI*2); ctx.arc(5,-8,2.5,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

function drawFrame(){
  frame++;
  let camX=player.x*TILE-canvas.width/2, camY=player.y*TILE-canvas.height/2;
  camX=clamp(camX,0,MAP_COLS*TILE-canvas.width);
  camY=clamp(camY,0,MAP_ROWS*TILE-canvas.height);

  ctx.fillStyle='#1a1a1a'; ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<MAP_ROWS;y++){
    for(let x=0;x<MAP_COLS;x++){
      const ch=maze[y][x];
      const sx=x*TILE-camX, sy=y*TILE-camY;
      ctx.fillStyle=ch==='W'?'#444':'#222'; ctx.fillRect(sx,sy,TILE,TILE);
    }
  }

  ctx.fillStyle='#2ecc71'; ctx.fillRect((MAP_COLS-2)*TILE-camX+6,(MAP_ROWS-2)*TILE-camY+6,TILE-12,TILE-12);
  ctx.fillStyle='#0ff'; ctx.fillRect(player.x*TILE-camX,player.y*TILE-camY,TILE,TILE);

  ghosts.forEach(g=>{
    ctx.globalAlpha=(g.stunUntil>performance.now())?0.6:1.0;
    drawGhost(g,camX,camY);
  });
  ctx.globalAlpha=1.0;

  bullets.forEach(b=>{
    ctx.fillStyle='yellow';
    const bx=b.x*TILE-camX, by=b.y*TILE-camY;
    ctx.beginPath(); ctx.arc(bx,by,4,0,Math.PI*2); ctx.fill();
  });

  // flashlight
  if(flashlightOn){
    ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    const LIGHT=420, cx=player.x*TILE-camX+TILE/2, cy=player.y*TILE-camY+TILE/2;
    const grad=ctx.createRadialGradient(cx,cy,LIGHT*0.05,cx,cy,LIGHT);
    grad.addColorStop(0,'rgba(255,255,255,0.9)'); grad.addColorStop(0.25,'rgba(255,255,255,0.6)');
    grad.addColorStop(0.5,'rgba(0,0,0,0.25)'); grad.addColorStop(1,'rgba(0,0,0,0.7)');
    ctx.globalCompositeOperation='multiply'; ctx.fillStyle=grad;
    ctx.beginPath(); ctx.arc(cx,cy,LIGHT,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over';
  } else { ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,canvas.width,canvas.height); }

  ctx.fillStyle='white'; ctx.font='14px Arial';
  ctx.fillText(`Level: ${level}`,12,20); ctx.fillText(`Ammo: ${ammo} / ${DIFF[difficulty].maxAmmo}`,12,40);
  ctx.fillText(`Ghosts: ${ghosts.length}`,12,60);
}

// ---------- Game Tick ----------
let lastGhostTick=0, lastBulletTick=0;
function gameTick(){
  if(keys['ArrowUp']||keys['w']) tryMove(0,-1);
  if(keys['ArrowDown']||keys['s']) tryMove(0,1);
  if(keys['ArrowLeft']||keys['a']) tryMove(-1,0);
  if(keys['ArrowRight']||keys['d']) tryMove(1,0);

  // ghost move
  const now=performance.now();
  ghosts.forEach(g=>{
    if(g.stunUntil>now) return;
    if(now-g.lastMove>DIFF[difficulty].ghostSpeed){
      g.lastMove=now;
      const next=stepTowards(g.x,g.y,player.x,player.y);
      g.x=next.x; g.y=next.y;
    }
  });

  // bullets
  if(now-lastBulletTick>16){
    lastBulletTick=now;
    bullets.forEach((b,i)=>{
      // move bullet upward for simplicity
      b.y-=0.15; 
      // check collision
      ghosts.forEach(g=>{
        const d=Math.abs(g.x-b.x)+Math.abs(g.y-b.y);
        if(d<1.2){ g.stunUntil=now+1500; const dx=Math.sign(g.x-player.x), dy=Math.sign(g.y-player.y); g.x+=dx; g.y+=dy; bullets.splice(i,1); }
      });
    });
    bullets=bullets.filter(b=>b.y>0);
  }

  // ammo regen every 30s
  if(now-lastAmmoRegen>30000){ lastAmmoRegen=now; if(ammo<DIFF[difficulty].maxAmmo) ammo++; updateHUD(); }

  // check win
  if(player.x===MAP_COLS-2 && player.y===MAP_ROWS-2){ level++; startLevel(); }

  // check lose
  for(const g of ghosts){ if(Math.round(g.x)===player.x && Math.round(g.y)===player.y){ alert('你被抓到了'); showMenu(); break; } }

  updateHUD();
}

// ---------- Main Loop ----------
function frameLoop(){ drawFrame(); if(started&&!gameOver) gameTick(); requestAnimationFrame(frameLoop); }
frameLoop();

showMenu();
</script>
</body>
</html>






</html>






</script>


