<!DOCTYPE html>
<html>
  <head>
    <title>great</title>
    <link rel="icon"href="icon.png.png">
  </head>
  <body>
    <script>
/* ================= 基本設定 ================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resize(){canvas.width=innerWidth;canvas.height=innerHeight;}
addEventListener('resize',resize);resize();

const TILE=28, COLS=40, ROWS=40;
const DIFF={
  EASY:{ammo:3,ghost:30},
  NORMAL:{ammo:5,ghost:20},
  HARD:{ammo:8,ghost:14},
  HELL:{ammo:8,ghost:9}
};

/* ================= 狀態 ================= */
let maze=[], bullets=[], ghosts=[];
let player={x:1,y:1};
let started=false, difficulty='NORMAL', level=1;
let ammo=0, maxAmmo=0, lastAmmoRegen=0;
const AMMO_REGEN_TIME=30000;
const keys={};

/* ================= 輸入 ================= */
addEventListener('keydown',e=>{
  keys[e.key]=true;
  if(e.key===' ') shoot();
});
addEventListener('keyup',e=>keys[e.key]=false);

/* ================= 迷宮 ================= */
function generateMaze(w,h){
  const g=Array.from({length:h},()=>Array(w).fill('W'));
  function carve(x,y){
    g[y][x]='.';
    [[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5)
      .forEach(([dx,dy])=>{
        const nx=x+dx, ny=y+dy;
        if(nx>0&&ny>0&&nx<w-1&&ny<h-1&&g[ny][nx]==='W'){
          g[y+dy/2][x+dx/2]='.'; carve(nx,ny);
        }
      });
  }
  carve(1,1);
  g[h-2][w-2]='.';
  return g;
}
function isWalkable(x,y){
  return x>=0&&y>=0&&x<COLS&&y<ROWS&&maze[y][x]!== 'W';
}

/* ================= BFS 必經路 ================= */
function findPath(sx,sy,ex,ey){
  const q=[{x:sx,y:sy}], prev=Array.from({length:ROWS},()=>Array(COLS).fill(null));
  const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
  vis[sy][sx]=true;
  while(q.length){
    const {x,y}=q.shift();
    if(x===ex&&y===ey) break;
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if(isWalkable(nx,ny)&&!vis[ny][nx]){
        vis[ny][nx]=true;
        prev[ny][nx]={x,y};
        q.push({x:nx,y:ny});
      }
    });
  }
  const path=[];
  let cur={x:ex,y:ey};
  while(cur){path.push(cur);cur=prev[cur.y][cur.x];}
  return path.reverse();
}

/* ================= Spawn ================= */
function spawn(){
  maze=generateMaze(COLS,ROWS);
  player={x:1,y:1};
  bullets=[]; ghosts=[];
  const path=findPath(player.x,player.y,COLS-2,ROWS-2);
  const base=3+level;
  const AI=['CHASER','PREDICTOR','FLANKER','WANDERER','ELITE'];

  for(let i=0;i<base;i++){
    let pos;
    if(i<base*0.6){
      const idx=Math.floor(path.length*(0.3+0.5*Math.random()));
      pos=path[idx];
    }else{
      do{
        pos={x:Math.random()*COLS|0,y:Math.random()*ROWS|0};
      }while(!isWalkable(pos.x,pos.y));
    }
    ghosts.push({
      x:pos.x,y:pos.y,
      ai:AI[i%AI.length],
      knockX:0,knockY:0,knockT:0,stun:0
    });
  }

  const elite=ghosts.find(g=>g.ai==='ELITE');
  if(elite){
    const p=path[path.length-6];
    elite.x=p.x; elite.y=p.y;
  }

  maxAmmo=DIFF[difficulty].ammo;
  ammo=maxAmmo;
  lastAmmoRegen=performance.now();
}

/* ================= 射擊 ================= */
function shoot(){
  if(ammo<=0) return;
  ammo--;
  let dx=0,dy=-1;
  if(keys.ArrowLeft||keys.a) dx=-1;
  else if(keys.ArrowRight||keys.d) dx=1;
  else if(keys.ArrowDown||keys.s) dy=1;

  bullets.push({x:player.x+.5,y:player.y+.5,vx:dx*.4,vy:dy*.4,life:40});
}

/* ================= 更新 ================= */
let lastMove=0,lastGhost=0;
function update(){
  const now=performance.now();

  if(now-lastMove>120){
    if(keys.ArrowUp||keys.w) move(0,-1);
    else if(keys.ArrowDown||keys.s) move(0,1);
    else if(keys.ArrowLeft||keys.a) move(-1,0);
    else if(keys.ArrowRight||keys.d) move(1,0);
  }

  bullets=bullets.filter(b=>{
    b.x+=b.vx; b.y+=b.vy; b.life--;
    if(!isWalkable(b.x|0,b.y|0)) return false;
    for(const g of ghosts){
      if(Math.abs(g.x-b.x)<.6&&Math.abs(g.y-b.y)<.6){
        g.knockX=Math.sign(g.x-player.x);
        g.knockY=Math.sign(g.y-player.y);
        g.knockT=g.ai==='ELITE'?3:8;
        g.stun=now+(g.ai==='ELITE'?300:800);
        return false;
      }
    }
    return b.life>0;
  });

  if(now-lastGhost>DIFF[difficulty].ghost*16){
    lastGhost=now;
    ghosts.forEach(g=>{
      if(g.knockT>0){
        const nx=g.x+g.knockX, ny=g.y+g.knockY;
        if(isWalkable(nx,ny)){g.x=nx;g.y=ny;}
        g.knockT--; return;
      }
      if(g.stun>now) return;
      const tx=player.x, ty=player.y;
      const dx=Math.sign(tx-g.x), dy=Math.sign(ty-g.y);
      if(isWalkable(g.x+dx,g.y)) g.x+=dx;
      else if(isWalkable(g.x,g.y+dy)) g.y+=dy;
    });
  }

  if(ammo<maxAmmo && now-lastAmmoRegen>AMMO_REGEN_TIME){
    ammo++; lastAmmoRegen=now;
  }

  if(player.x===COLS-2&&player.y===ROWS-2){
    alert('過關！'); level++; spawn();
  }
}

/* ================= 繪製 ================= */
function draw(){
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const camX=player.x*TILE-canvas.width/2;
  const camY=player.y*TILE-canvas.height/2;

  for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
    ctx.fillStyle=maze[y][x]==='W'?'#444':'#222';
    ctx.fillRect(x*TILE-camX,y*TILE-camY,TILE,TILE);
  }

  ctx.fillStyle='#0ff';
  ctx.fillRect(player.x*TILE-camX,player.y*TILE-camY,TILE,TILE);

  ghosts.forEach(g=>{
    const cx=g.x*TILE-camX+TILE/2;
    const cy=g.y*TILE-camY+TILE/2;
    if(g.ai==='ELITE'){
      ctx.strokeStyle='#ff0';
      ctx.beginPath();
      ctx.arc(cx,cy,14+Math.sin(performance.now()/200)*2,0,Math.PI*2);
      ctx.stroke();
      ctx.fillStyle='#c00';
    }else{
      ctx.fillStyle='#e33';
    }
    ctx.beginPath(); ctx.arc(cx,cy,10,0,Math.PI*2); ctx.fill();
  });

  ctx.fillStyle='#fff';
  bullets.forEach(b=>{
    ctx.beginPath();
    ctx.arc(b.x*TILE-camX,b.y*TILE-camY,3,0,Math.PI*2);
    ctx.fill();
  });

  ctx.fillStyle='rgba(0,0,0,.65)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  const cx=player.x*TILE-camX+TILE/2;
  const cy=player.y*TILE-camY+TILE/2;
  const grad=ctx.createRadialGradient(cx,cy,50,cx,cy,300);
  grad.addColorStop(0,'rgba(0,0,0,0)');
  grad.addColorStop(1,'rgba(0,0,0,1)');
  ctx.globalCompositeOperation='destination-out';
  ctx.fillStyle=grad;
  ctx.beginPath(); ctx.arc(cx,cy,300,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='source-over';
}

/* ================= 主迴圈 ================= */
function move(dx,dy){
  const nx=player.x+dx, ny=player.y+dy;
  if(isWalkable(nx,ny)){player.x=nx;player.y=ny; lastMove=performance.now();}
}
function loop(){
  if(started){update(); draw();}
  requestAnimationFrame(loop);
}
loop();

function startGame(d){
  difficulty=d; started=true; level=1; spawn();
}
</script>



</html>






</script>


