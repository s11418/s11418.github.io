<!DOCTYPE html>
<html>
  <head>
    <title>great</title>
    <link rel="icon"href="icon.png.png">
  </head>
  <body>
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Labyrinth Hotel Escape - Web</title>
<style>
  body {
    margin: 0;
    background: #000;
    overflow: hidden;
}
  canvas {
    border: 3px solid #fff;
  }
</style>
</head>
<body>
<canvas id="game"></canvas></canvas>
<script>
// --- Maze Map (W = Wall, . = Floor, G = Goal) ---
const maze = [
  "WWWWWWWWWWWWWWWWWWWW",
  "W........W.........W",
  "W.WWWW.W.WWW.WWWW.WW",
  "W.W....W.....W.....W",
  "W.W.WWWW.WWWWW.WWW.W",
  "W.W.W....W.....W...W",
  "W.W.W.WWWW.WWW.W.WWW",
  "W...W......W...W...W",
  "W.WWWWWWW.W.W.WWWWWW",
  "W.....W...W.W......G",
  "WWWWWWWWWWWWWWWWWWWW"
];

const TILE = 32;
const canvas = document.getElementById("game");
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();
const ctx = canvas.getContext("2d");

let player = { x: 1, y: 1 };
let ghost = { x: 10, y: 5, mode: "patrol", timer: 0 };

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // --- Camera center on player ---
  // --- Camera center on player but clamped ---
  let camX = player.x * TILE - canvas.width / 2 + TILE / 2;
  let camY = player.y * TILE - canvas.height / 2 + TILE / 2;

  // Clamp so camera never shows too much empty space
  camX = Math.max(0, Math.min(camX, maze[0].length * TILE - canvas.width));
  camY = Math.max(0, Math.min(camY, maze.length * TILE - canvas.height));

  for (let y = 0; y < maze.length; y++) {
    for (let x = 0; x < maze[y].length; x++) {
      const screenX = x * TILE - camX;
      const screenY = y * TILE - camY;

      if (screenX < -TILE || screenX > canvas.width) continue;
      if (screenY < -TILE || screenY > canvas.height) continue;

      if (maze[y][x] === "W") {
        ctx.fillStyle = "#333";
        ctx.fillRect(screenX, screenY, TILE, TILE);
      } else if (maze[y][x] === "G") {
        ctx.fillStyle = "#0f0";
        ctx.fillRect(screenX, screenY, TILE, TILE);
      }
    }
  }

  // Player
  ctx.fillStyle = "#0ff";
  ctx.fillRect(player.x * TILE - camX, player.y * TILE - camY, TILE, TILE);

  // Ghost (Shadow Monster)
  ctx.save();
  ctx.translate(ghost.x * TILE - camX + TILE/2, ghost.y * TILE - camY + TILE/2);

  // head
  ctx.beginPath();
  ctx.fillStyle = "black";
  ctx.arc(0, -6, 10, 0, Math.PI * 2);
  ctx.fill();

  // body
  ctx.beginPath();
  ctx.moveTo(-12, 0);
  ctx.lineTo(0, 16);
  ctx.lineTo(12, 0);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

// --- Check Win & Lose ---
function checkState() {
  if (maze[player.y][player.x] === "G") {
    alert("你成功逃出鬼店！");
    reset();
  }

  if (player.x === ghost.x && player.y === ghost.y) {
    alert("你被惡鬼抓到了！");
    reset();
  }
}

function reset() {
  player = { x: 1, y: 1 };
  ghost = { x: 10, y: 5, timer: 0 };
}

function loop() {
  ghostAI();
  draw();
  checkState();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>





</script>


