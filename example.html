<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Labyrinth Hotel — Web Game</title>
<style>
html,body{margin:0;padding:0;height:100%;background:#111;overflow:hidden}
canvas{display:block;width:100vw;height:100vh;background:#1a1a1a}
.overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);color:#fff;z-index:10}
.menu{background:#2a2a2a;padding:20px;border-radius:12px;text-align:center}
.btn{padding:10px 18px;margin:5px;border-radius:6px;border:none;cursor:pointer;font-weight:700}
.btn-easy{background:#2ecc71}
.btn-normal{background:#f1c40f;color:#000}
.btn-hard{background:#e67e22}
.btn-hell{background:#e74c3c}
#hud{position:fixed;top:12px;left:12px;color:#fff;font-weight:700}
#hud div{margin-bottom:6px}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="menuOverlay" class="overlay">
  <div class="menu">
    <h2>迷跡旅館 — 選擇難度</h2>
    <div>方向鍵 / WASD 移動，空白鍵射擊</div>
    <button class="btn btn-easy" onclick="startGame('EASY')">EASY</button>
    <button class="btn btn-normal" onclick="startGame('NORMAL')">NORMAL</button>
    <button class="btn btn-hard" onclick="startGame('HARD')">HARD</button>
    <button class="btn btn-hell" onclick="startGame('HELL')">HELL</button>
  </div>
</div>

<div id="hud" style="display:none">
  <div id="levelText"></div>
  <div id="diffText"></div>
  <div id="ammoText"></div>
  <div id="ghostText"></div>
</div>

<script>
// ===== Canvas =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let TILE;
const MAP_COLS=40, MAP_ROWS=40;
function resize(){
  canvas.width=innerWidth;
  canvas.height=innerHeight;
  TILE=Math.min(canvas.width/MAP_COLS,canvas.height/MAP_ROWS);
}

// ===== Difficulty =====
const DIFF={
  EASY:{ghostCount:3,speed:1,maxAmmo:3},
  NORMAL:{ghostCount:4,speed:1.5,maxAmmo:4},
  HARD:{ghostCount:6,speed:2,maxAmmo:6},
  HELL:{ghostCount:8,speed:2.5,maxAmmo:8}
};

// ===== State =====
let maze=[], player={x:1,y:1}, ghosts=[], bullets=[];
let level=1, difficulty='NORMAL', started=false, gameOver=true;
let ammo=0, lastAmmoRegen=performance.now();
const AMMO_REGEN_INTERVAL=4000;

// ===== Input =====
const keys={};
addEventListener('keydown',e=>keys[e.key]=true);
addEventListener('keyup',e=>keys[e.key]=false);

// ===== HUD =====
const menuOverlay=document.getElementById('menuOverlay');
const hud=document.getElementById('hud');
const levelText=document.getElementById('levelText');
const diffText=document.getElementById('diffText');
const ammoText=document.getElementById('ammoText');
const ghostText=document.getElementById('ghostText');

function updateHUD(){
  levelText.textContent=`Level: ${level}`;
  diffText.textContent=`Difficulty: ${difficulty}`;
  ammoText.textContent=`Ammo: ${ammo}/${DIFF[difficulty].maxAmmo}`;
  ghostText.textContent=`Ghosts: ${ghosts.length}`;
}

// ===== Maze =====
function generateMaze(c,r){
  const g=Array.from({length:r},()=>Array(c).fill('W'));
  function carve(x,y){
    g[y][x]='.';
    [{x:2,y:0},{x:-2,y:0},{x:0,y:2},{x:0,y:-2}]
      .sort(()=>Math.random()-0.5)
      .forEach(d=>{
        const nx=x+d.x, ny=y+d.y;
        if(nx>0&&ny>0&&nx<c-1&&ny<r-1&&g[ny][nx]==='W'){
          g[y+d.y/2|0][x+d.x/2|0]='.';
          carve(nx,ny);
        }
      });
  }
  carve(1,1);
  g[r-2][c-2]='.';
  return g;
}

// ===== Spawn =====
function startLevel(){
  maze=generateMaze(MAP_COLS,MAP_ROWS);
  spawnPlayer();
  spawnGhosts();
  ammo=DIFF[difficulty].maxAmmo;
  lastAmmoRegen=performance.now();
  updateHUD();
}

function spawnPlayer(){
  for(let y=0;y<MAP_ROWS;y++)
    for(let x=0;x<MAP_COLS;x++)
      if(maze[y][x]==='.'){player={x,y};return;}
}

function spawnGhosts(){
  ghosts=[];
  for(let i=0;i<DIFF[difficulty].ghostCount;i++){
    let x,y;
    do{
      x=Math.random()*(MAP_COLS-2)|0+1;
      y=Math.random()*(MAP_ROWS-2)|0+1;
    }while(maze[y][x]!=='.');
    ghosts.push({x,y,stunUntil:0});
  }
}

// ===== Auto Aim Helper =====
function getNearestGhosts(count){
  return ghosts
    .filter(g=>performance.now()>=g.stunUntil)
    .map(g=>{
      const dx=(g.x+0.5)-(player.x+0.5);
      const dy=(g.y+0.5)-(player.y+0.5);
      return {g,dist:Math.hypot(dx,dy)};
    })
    .sort((a,b)=>a.dist-b.dist)
    .slice(0,count)
    .map(o=>o.g);
}

// ===== Shooting =====
addEventListener('keydown',e=>{
  if(e.key===' '&&started&&!gameOver){
    e.preventDefault();
    shoot();
  }
});

function shoot(){
  if(ammo<=0) return;
  const targets=getNearestGhosts(3);
  if(targets.length===0) return;

  ammo--; updateHUD();
  const px=player.x+.5, py=player.y+.5;
  const speed=0.6;

  targets.forEach(t=>{
    let dx=(t.x+.5)-px, dy=(t.y+.5)-py;
    const len=Math.hypot(dx,dy)||1;
    bullets.push({
      x:px,y:py,
      dx:dx/len*speed,
      dy:dy/len*speed,
      ttl:25
    });
  });
}

// ===== Game Loop =====
function gameTick(){
  let dx=0,dy=0;
  if(keys.w||keys.ArrowUp)dy=-1;
  if(keys.s||keys.ArrowDown)dy=1;
  if(keys.a||keys.ArrowLeft)dx=-1;
  if(keys.d||keys.ArrowRight)dx=1;
  if(dx||dy) move(dy,dx);

  const now=performance.now();

  ghosts.forEach(g=>{
    if(g.stunUntil>now) return;
    const dx=player.x-g.x, dy=player.y-g.y;
    const d=Math.hypot(dx,dy);
    if(d<.5) lose();
    g.x+=dx/d*DIFF[difficulty].speed*.04;
    g.y+=dy/d*DIFF[difficulty].speed*.04;
  });

  bullets.forEach(b=>{
    b.x+=b.dx; b.y+=b.dy; b.ttl--;
    ghosts.forEach(g=>{
      if(Math.abs(g.x+0.5-b.x)<0.8&&Math.abs(g.y+0.5-b.y)<0.8){
        g.stunUntil=now+1500;
        b.ttl=0;
      }
    });
  });
  bullets=bullets.filter(b=>b.ttl>0);

  if(now-lastAmmoRegen>AMMO_REGEN_INTERVAL){
    lastAmmoRegen=now;
    if(ammo<DIFF[difficulty].maxAmmo){ammo++;updateHUD();}
  }
}

function move(dy,dx){
  const nx=player.x+dx, ny=player.y+dy;
  if(maze[ny]?.[nx]==='.') player={x:nx,y:ny};
}

// ===== Draw =====
function draw(){
  ctx.fillStyle='#1a1a1a';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  for(let y=0;y<MAP_ROWS;y++)
    for(let x=0;x<MAP_COLS;x++){
      ctx.fillStyle=maze[y][x]==='W'?'#666':'#333';
      ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    }

  ctx.fillStyle='#ffff66';
  bullets.forEach(b=>ctx.fillRect(b.x*TILE,b.y*TILE,4,4));

  ctx.fillStyle='#ff5555';
  ghosts.forEach(g=>{
    if(performance.now()<g.stunUntil) ctx.fillStyle='#fff';
    else ctx.fillStyle='#ff5555';
    ctx.fillRect(g.x*TILE,g.y*TILE,TILE,TILE);
  });

  ctx.fillStyle='#00ffff';
  ctx.fillRect(player.x*TILE,player.y*TILE,TILE,TILE);
}

function loop(){
  if(started&&!gameOver) gameTick();
  draw(); requestAnimationFrame(loop);
}

// ===== Flow =====
function startGame(d){
  difficulty=d; level=1;
  menuOverlay.style.display='none';
  hud.style.display='block';
  started=true; gameOver=false;
  startLevel();
}
function lose(){
  alert('你被鬼抓到了！');
  started=false; gameOver=true;
  menuOverlay.style.display='flex';
  hud.style.display='none';
}

addEventListener('resize',resize);
resize(); loop();
</script>
</body>
</html>
