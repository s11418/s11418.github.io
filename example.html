<!DOCTYPE html>
<html>
  <head>
    <title>great</title>
    <link rel="icon"href="icon.png.png">
  </head>
  <body>
   <!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<title>Labyrinth Horror</title>
<style>
html,body{margin:0;background:#000;overflow:hidden;font-family:Arial,sans-serif}
canvas{display:block}
.overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.75);color:#fff;z-index:10}
.menu{background:#222;padding:20px;border-radius:10px;text-align:center}
.btn{padding:10px 18px;margin:5px;border:none;border-radius:5px;font-weight:700;cursor:pointer}
.btn-easy{background:#2ecc71;color:#012}
.btn-normal{background:#f1c40f;color:#000}
.btn-hard{background:#e67e22;color:#000}
.btn-hell{background:#e74c3c;color:#fff}
#hud{position:fixed;left:10px;top:10px;color:#fff;font-weight:700;z-index:5}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="menuOverlay" class="overlay">
  <div class="menu">
    <h2>迷跡旅館 — 選擇難度</h2>
    <div style="margin:10px 0">
      <button class="btn btn-easy" onclick="startGame('EASY')">EASY</button>
      <button class="btn btn-normal" onclick="startGame('NORMAL')">NORMAL</button>
      <button class="btn btn-hard" onclick="startGame('HARD')">HARD</button>
      <button class="btn btn-hell" onclick="startGame('HELL')">HELL</button>
    </div>
    <div style="font-size:13px;opacity:0.8">EASY: 3 發 / NORMAL: 5 發 / HARD: 8 發 / HELL: 8 發，4 秒回 1 發</div>
  </div>
</div>

<div id="hud" style="display:none">
  <div id="levelText">Level: 1</div>
  <div id="ammoText">Ammo: 0 / 0</div>
  <div id="ghostText">Ghosts: 0</div>
</div>

<script>
/* ========= Canvas ========= */
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
function resize(){canvas.width=innerWidth;canvas.height=innerHeight}
addEventListener("resize",resize); resize();

/* ========= Config ========= */
const TILE=28, COLS=35, ROWS=35, LIGHT_RADIUS=260;
const DIFF={
  "EASY":{maxAmmo:3}, "NORMAL":{maxAmmo:5}, "HARD":{maxAmmo:8}, "HELL":{maxAmmo:8}
};

/* ========= State ========= */
let maze=[], ghosts=[], bullets=[];
let player={x:1,y:1};
let ammo=0, difficulty="NORMAL", level=1;
let started=false;
let lastAmmoTime=0;

/* ========= Input ========= */
const keys={};
addEventListener("keydown",e=>{
  keys[e.key]=true;
  if(e.key===" ") shoot();
});
addEventListener("keyup",e=>keys[e.key]=false);

/* ========= HUD / Menu ========= */
const menuOverlay=document.getElementById("menuOverlay");
const hud=document.getElementById("hud");
const levelText=document.getElementById("levelText");
const ammoText=document.getElementById("ammoText");
const ghostText=document.getElementById("ghostText");
function updateHUD(){
  levelText.textContent=`Level: ${level}`;
  ammoText.textContent=`Ammo: ${ammo} / ${DIFF[difficulty].maxAmmo}`;
  ghostText.textContent=`Ghosts: ${ghosts.length}`;
}

/* ========= Maze ========= */
function genMaze(w,h){
  const g=Array.from({length:h},()=>Array(w).fill("W"));
  function carve(x,y){
    g[y][x]=".";
    [[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-.5)
    .forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if(nx>0&&ny>0&&nx<w-1&&ny<h-1&&g[ny][nx]==="W"){
        g[y+dy/2][x+dx/2]=".";
        carve(nx,ny);
      }
    });
  }
  carve(1,1);
  g[h-2][w-2]=".";
  return g;
}
function walk(x,y){return maze[y]&&maze[y][x]==="."}

/* ========= Path ========= */
function findPath(){
  const q=[{x:1,y:1}], prev={};
  prev["1,1"]=null;
  while(q.length){
    const p=q.shift();
    if(p.x===COLS-2&&p.y===ROWS-2) break;
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=p.x+dx, ny=p.y+dy, k=`${nx},${ny}`;
      if(walk(nx,ny)&&!(k in prev)){ prev[k]=p; q.push({x:nx,y:ny}); }
    });
  }
  const path=[]; let cur={x:COLS-2,y:ROWS-2};
  while(cur){ path.push(cur); cur=prev[`${cur.x},${cur.y}`]; }
  return path.reverse();
}

/* ========= Spawn ========= */
function spawn(){
  maze=genMaze(COLS,ROWS);
  player={x:1,y:1};
  ghosts=[]; bullets=[];
  const path=findPath();

  // 普通鬼
  for(let i=4;i<path.length;i+=6){
    ghosts.push({x:path[i].x,y:path[i].y,type:"normal",stun:0});
  }
  // 精英鬼
  const p=path[Math.max(path.length-6,0)];
  ghosts.push({x:p.x,y:p.y,type:"elite",stun:0});

  ammo=DIFF[difficulty].maxAmmo;
  lastAmmoTime=performance.now();
  updateHUD();
}

/* ========= Shooting ========= */
function shoot(){
  if(ammo<=0) return;
  ammo--;
  bullets.push({x:player.x+.5,y:player.y+.5,dx:0,dy:-.4,life:40});
  updateHUD();
}

/* ========= Update ========= */
function update(){
  // player
  if(keys.ArrowUp&&walk(player.x,player.y-1))player.y--;
  if(keys.ArrowDown&&walk(player.x,player.y+1))player.y++;
  if(keys.ArrowLeft&&walk(player.x-1,player.y))player.x--;
  if(keys.ArrowRight&&walk(player.x+1,player.y))player.x++;

  // bullets
  bullets=bullets.filter(b=>{
    b.x+=b.dx; b.y+=b.dy; b.life--;
    ghosts.forEach(g=>{
      if(Math.abs(g.x-b.x)<.6&&Math.abs(g.y-b.y)<.6){
        g.stun=30;
        g.x+=Math.sign(g.x-player.x);
        g.y+=Math.sign(g.y-player.y);
        b.life=0;
      }
    });
    return b.life>0;
  });

  // ghosts
  ghosts.forEach(g=>{
    if(g.stun>0){ g.stun--; return; }
    const dx=Math.sign(player.x-g.x);
    const dy=Math.sign(player.y-g.y);
    if(walk(g.x+dx,g.y)) g.x+=dx;
    else if(walk(g.x,g.y+dy)) g.y+=dy;
  });

  // ammo regen every 30s if empty
  if(ammo<DIFF[difficulty].maxAmmo && performance.now()-lastAmmoTime>30000){
    ammo++; lastAmmoTime=performance.now(); updateHUD();
  }

  // win
  if(player.x===COLS-2 && player.y===ROWS-2){
    level++; startLevel();
  }

  // lose
  ghosts.forEach(g=>{
    if(Math.round(g.x)===player.x && Math.round(g.y)===player.y){
      alert("你被抓到了！遊戲結束");
      showMenu();
    }
  });
}

/* ========= Draw ========= */
function draw(){
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  const camX=player.x*TILE-canvas.width/2;
  const camY=player.y*TILE-canvas.height/2;

  for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
    ctx.fillStyle=maze[y][x]==="W"?"#444":"#222";
    ctx.fillRect(x*TILE-camX,y*TILE-camY,TILE,TILE);
  }

  // exit
  ctx.fillStyle="#2ecc71";
  ctx.fillRect((COLS-2)*TILE-camX,(ROWS-2)*TILE-camY,TILE,TILE);

  // player
  ctx.fillStyle="#0ff";
  ctx.fillRect(player.x*TILE-camX,player.y*TILE-camY,TILE,TILE);

  // ghosts
  ghosts.forEach(g=>{
    ctx.fillStyle=g.type==="elite"?"#ff0":"#e33";
    ctx.beginPath();
    ctx.arc(g.x*TILE-camX+14,g.y*TILE-camY+14,12,0,Math.PI*2);
    ctx.fill();
  });

  // bullets
  ctx.fillStyle="#fff";
  bullets.forEach(b=>{
    ctx.beginPath();
    ctx.arc(b.x*TILE-camX,b.y*TILE-camY,3,0,Math.PI*2);
    ctx.fill();
  });

  // 光照
  ctx.fillStyle="rgba(0,0,0,.7)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  const cx=player.x*TILE-camX+14, cy=player.y*TILE-camY+14;
  const g=ctx.createRadialGradient(cx,cy,50,cx,cy,LIGHT_RADIUS);
  g.addColorStop(0,"rgba(0,0,0,0)");
  g.addColorStop(1,"rgba(0,0,0,1)");
  ctx.globalCompositeOperation="destination-out";
  ctx.fillStyle=g;
  ctx.beginPath(); ctx.arc(cx,cy,LIGHT_RADIUS,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation="source-over";
}

/* ========= Loop ========= */
function loop(){ if(started){ update(); draw(); } requestAnimationFrame(loop); }
loop();

/* ========= Start / Menu ========= */
function showMenu(){
  started=false; menuOverlay.style.display="flex"; hud.style.display="none";
}
function startGame(diff){
  difficulty=diff; level=1;
  menuOverlay.style.display="none"; hud.style.display="block";
  started=true;
  startLevel();
}
function startLevel(){ spawn(); updateHUD(); }

</script>
</body>
</html>




</html>






</script>


